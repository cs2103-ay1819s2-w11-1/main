<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.6.1"><title>Kuan Wei Heng - Project Portfolio for TopDeck</title><link rel="stylesheet" href="../stylesheets/gh-pages.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../stylesheets/coderay-asciidoctor.css"></head><body class="article"><div id="site-header"><nav class="navbar navbar-light bg-light"><div class="container"><a class="navbar-brand" href="../index.html">TopDeck</a><ul class="navbar-nav"><li class="nav-item"><a class="nav-link" href="../UserGuide.html">User Guide</a></li><li class="nav-item"><a class="nav-link active" href="../DeveloperGuide.html">Developer Guide</a></li><li class="nav-item"><a class="nav-link" href="../AboutUs.html">About Us</a></li><li class="nav-item"><a class="nav-link" href="../ContactUs.html">Contact Us</a></li><li class="navitem"><a class="nav-link" href="https://github.com/cs2103-ay1819s2-w11-1/main"><span class="fa fa-github fa-lg" aria-hidden="true"></span>&nbsp;View on GitHub</a></li></ul></div></nav></div><div id="header"><h1>Kuan Wei Heng - Project Portfolio for TopDeck</h1></div><div id="content"><div class="sect1">
<h2 id="overview"><a class="link" href="#overview">1. Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document serves to document my contributions to TopDeck, the project I worked on
while taking the introductory software engineering module in NUS.
TopDeck is a flash card application built on top of the code from
<a href="https://github.com/nus-cs2103-AY1819S1/addressbook-level4">Addressbook Level 4</a> (AB4).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary-of-contributions"><a class="link" href="#summary-of-contributions">2. Summary of Contributions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section summarises my key contributions to TopDeck:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Major Enhancement</strong>: I added state to the user interface.</p>
<div class="ulist">
<ul>
<li>
<p>What it does: A stateful interface looks and behave differently depending
on the state of the applicaton.</p>
</li>
<li>
<p>Justification: Having state in the user interface enhances usability in
many ways. It offers a useful mental model for users by exposing features
only when they are relevant to what a user is currently doing. It allows
us to assign multiple related features to the same command word (since
they can be disambiguated by state), minimizing the total number of unique
commands words. It also leads to shorter commands in general since TopDeck
does not have to request information from users that may be already be
inferred from the current state.</p>
</li>
<li>
<p>Highlights: AB4 could not be readily adapted to support state because it
was designed around assumptions that do not hold with a stateful user
interface in full generality. AB4 has a static user interface that assumes
there always exists a list of items. This assumption runs so deep that
first-class access to <code>filteredList</code> and <code>selectedItem</code> is provided
through the <code>Model</code> API. So I had to rewrite <code>Model</code>. I also had to modify
many subsystems (such as parsing) along the pipeline of a typical command
execution. As a result of my work, the rest of my team could work on their
features independently and easily integrate their work through the new API
I designed.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Minor Enhancement</strong>: I added argument completion to the edit commands
(the remaining exposition will focus on the edit card command).</p>
<div class="ulist">
<ul>
<li>
<p>What it does: The edit card command has an abbreviated form <code>edit INDEX</code>.
This prefills the command box with an expanded command which, if submitted
verbatim, leaves the card at <code>INDEX</code> unchanged.</p>
</li>
<li>
<p>Justification: This feature is meant to be a shortcut for making small
edits. Suppose a user notices a typo in a question. Instead of retyping
the entire question, they can quickly expand all arguments to the edit
command and edit the question from there.</p>
</li>
<li>
<p>Highlights: Completion is a feature that interacts with the command box
and is implemented by defining a new subclass of <code>CommandResult</code> that
holds the string to be prefilled. In general, commands that need to
interact with <code>UI</code> through <code>MainWindow</code> do so by returning an appropriate
subclass of <code>CommandResult</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Code Contributed</strong>: <a href="https://nus-cs2103-ay1819s2.github.io/cs2103-dashboard/#search=xsot">CS2103T Dashboard</a></p>
</div>
<div class="paragraph">
<p><strong>Other contributions</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project management:</p>
<div class="ulist">
<ul>
<li>
<p>I ensured the group stayed on schedule.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enhancements to existing features:</p>
<div class="ulist">
<ul>
<li>
<p>I refactored a lot of code to support stateful user interface.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Documentation:</p>
<div class="ulist">
<ul>
<li>
<p>I adapted the AB4 developer guide to fit our project.</p>
</li>
<li>
<p>I enhanced the look of our documentation by tweaking the CSS.</p>
</li>
<li>
<p>I polished our documentation according to the standards set by our CS2101
tutor.</p>
</li>
<li>
<p>I proofread sections of the documentation that were not explicitly assigned
to anyone.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Community:</p>
<div class="ulist">
<ul>
<li>
<p>I led the design of the user interface and user experience.</p>
</li>
<li>
<p>I reviewed pull requests (with non-trivial review comments): <a href="https://github.com/cs2103-ay1819s2-w11-1/main/pull/8">#8</a>, <a href="https://github.com/cs2103-ay1819s2-w11-1/main/pull/39">#39</a>, <a href="https://github.com/cs2103-ay1819s2-w11-1/main/pull/77">#77</a></p>
</li>
<li>
<p>I reported some subtle bugs: <a href="https://github.com/cs2103-ay1819s2-w11-1/main/issues/7">#7</a>, <a href="https://github.com/cs2103-ay1819s2-w11-1/main/issues/63">#63</a></p>
</li>
<li>
<p>I gave our team a few tips on the git workflow.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tools:</p>
<div class="ulist">
<ul>
<li>
<p>I configured the team repository on Github and integrated the suggested
services into our workflow (TravisCI, AppVeyor, Coveralls).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-user-guide"><a class="link" href="#contributions-to-user-guide">3. Contributions to User Guide</a></h2>
<div class="sectionbody">
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>This section contains excerpts of my contributions to the user guide.
They showcase my ability to write documentation for non-technical users.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="introduction"><a class="link" href="#introduction">3.1. Introduction</a></h3>
<div class="paragraph">
<p>TopDeck is a desktop app for anyone who relies on flash cards to memorise things.</p>
</div>
<div class="paragraph">
<p>TopDeck helps you digitise your flash cards and keeps them organised.
You can easily review your cards and TopDeck will track your performance.
Improve your memory without the hassle of managing a physical pile of cards!</p>
</div>
<div class="paragraph">
<p>TopDeck has a Command Line Interface (CLI), which means you interact with it by typing commands.
TopDeck can be operated entirely using the keyboard!</p>
</div>
<div class="paragraph">
<p>If this sounds like the tool you have been looking for,
jump to <a href="#Quick start">[Quick start]</a> to get started. Enjoy!</p>
</div>
</div>
<div class="sect2">
<h3 id="user-interface"><a class="link" href="#user-interface">3.2. User interface</a></h3>
<div class="paragraph">
<p>TopDeck&#8217;s interface is very simple. It consists of four main areas - the
Menu Bar, the Command Box, the Results Display, and the Content Panel.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/gen_ug_diagrams/ui_annotate.png" alt="ui annotate" width="600">
</div>
<div class="title">Figure 1. Main areas in the user interface</div>
</div>
<div class="paragraph">
<p>Here are the uses of each part of the interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Menu Bar: Provides access to general commands such as <code>exit</code> and <code>help</code> with dropdowns.</p>
</li>
<li>
<p>Command Box: This is where you input commands to interact with the application.</p>
</li>
<li>
<p>Results Display: This area shows the outcome of your commands.</p>
</li>
<li>
<p>Content Panel: This is the main display area and changes depending on what you are doing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TopDeck&#8217;s functionality is separated into three distinct <em>views</em> - decks view, cards view and study view.
The interface shown in the Content Panel and the commands available change depending on the view.
By default, TopDeck starts in decks view.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Navigation.png" alt="Navigation" width="800">
</div>
<div class="title">Figure 2. Navigating the views in TopDeck</div>
</div>
<div class="paragraph">
<p>The figure above provides a brief overview of the different views and shows how you may navigate between them.
In general, the commands <code>open</code>, <code>study</code> and <code>back</code> are used to navigate to cards view, study view and decks view respectively.
For more information about these commands, go to <a href="#Commands">[Commands]</a>.</p>
</div>
<div class="paragraph">
<p>The following sections will describe each view in more detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="decksview"><a class="link" href="#decksview">3.3. Decks view</a></h3>
<div class="imageblock" style="float: right">
<div class="content">
<img src="../images/deck_ug_diagrams/deck.png" alt="deck" width="300">
</div>
<div class="title">Figure 3. Decks view</div>
</div>
<div class="paragraph">
<p>Decks view displays a list of the decks in your collection.
The figure to the right shows a typical TopDeck session in decks view.</p>
</div>
<div class="paragraph">
<p>In decks view, you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a new deck.</p>
</li>
<li>
<p>Edit, delete, or search for an existing deck.</p>
</li>
<li>
<p>Open a deck to view its contents. TopDeck will open the deck in <a href="#cardsview">cards view</a>.</p>
</li>
<li>
<p>Pick a deck to study. TopDeck will use the deck in <a href="#studyview">study view</a>.</p>
</li>
<li>
<p>Export a deck in your collection or import a deck from your computer to TopDeck.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You may find the corresponding commands for the features in decks view <a href="#decksviewc">here</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="cardsview"><a class="link" href="#cardsview">3.4. Cards view</a></h3>
<div class="imageblock" style="float: right">
<div class="content">
<img src="../images/gen_ug_diagrams/cards.png" alt="cards" width="300">
</div>
<div class="title">Figure 4. Cards view</div>
</div>
<div class="paragraph">
<p>Cards view displays the cards in a particular deck.
The figure to the right shows a typical TopDeck session in cards view.</p>
</div>
<div class="paragraph">
<p>In cards view, you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a new card and add it to the deck.</p>
</li>
<li>
<p>Edit, delete, or search for an existing card in the deck.</p>
</li>
<li>
<p>View your past study performance for specific cards.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You may find the corresponding commands for the features in cards view <a href="#cardsviewc">here</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="studyview"><a class="link" href="#studyview">3.5. Study view</a></h3>
<div class="imageblock" style="float: right">
<div class="content">
<img src="../images/gen_ug_diagrams/study.png" alt="study" width="300">
</div>
<div class="title">Figure 5. Study view</div>
</div>
<div class="paragraph">
<p>In study view, TopDeck helps you to study a particular deck.
The figure to the right shows a typical TopDeck session in study view.</p>
</div>
<div class="paragraph">
<p>The cards from a particular deck will be shown one at a time.
TopDeck will first show a question.
You may then reveal the answer and verify if it matches your answer.
Finally, you may rate how well you think you performed for that card before moving on to the next card.
TopDeck automates the bookkeeping for you.</p>
</div>
<div class="paragraph">
<p>You may find a more precise decription of the commands used in cards view <a href="#cardsviewc">here</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-developer-guide"><a class="link" href="#contributions-to-developer-guide">4. Contributions to Developer Guide</a></h2>
<div class="sectionbody">
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>This section contains excerpts of my contributions to the developer guide.
They showcase my ability to write technical documentation and the technical depth of my contributions to TopDeck.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Design-Ui"><a class="link" href="#Design-Ui">4.1. UI component</a></h3>
<div class="imageblock">
<div class="content">
<img src="../images/UiClassDiagram.png" alt="UiClassDiagram" width="800">
</div>
<div class="title">Figure 6. Structure of the UI Component</div>
</div>
<div class="paragraph">
<p>The <code>UI</code> component is responsible for the user interface. It relays user commands to <code>Logic</code> for execution
and updates the user interface according to the application data in <code>Model</code>.</p>
</div>
<div class="paragraph">
<p><code>UI</code> consists of a <code>MainWindow</code> that owns instances of the classes that make up the user interface such as <code>CommandBox</code>.
Notably, <code>MainWindow</code> owns a <code>MainPanel</code> which is a reference type to one of the possible main panels.
Its concrete type is dependent on <code>ViewState</code> from <code>Model</code>. The figure below shows how the user interface is divided into classes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/UiClasses.png" alt="UiClasses" width="600">
</div>
</div>
<div class="paragraph">
<p><code>MainWindow</code> and all its owned classes extend <code>UiPart</code> which is an abstract class that represents a unit that can be rendered to the display.
<code>UI</code> uses the JavaFx UI framework. By convention, the layout of each <code>UIPart</code> is defined in the corresponding <code>.fxml</code> file in <code>src/main/resources/view</code>.
For example, the layout of <code>MainWindow</code> is defined in <code>MainWindow.fxml</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="Design-Logic"><a class="link" href="#Design-Logic">4.2. Logic component</a></h3>
<div id="fig-LogicClassDiagram" class="imageblock">
<div class="content">
<img src="../images/LogicClassDiagram.png" alt="LogicClassDiagram" width="800">
</div>
<div class="title">Figure 7. Structure of the Logic Component</div>
</div>
<div class="paragraph">
<p>The <code>Logic</code> component is responsible for parsing and executing commands. A typical command is parsed and executed as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Logic</code> uses the <code>TopDeckParser</code> class to parse the user command into a command word and its arguments.</p>
</li>
<li>
<p><code>TopDeckParser</code> requests for the <code>ViewStateParser</code> from the active <code>ViewState</code> in <code>Model</code>.</p>
</li>
<li>
<p>This <code>ViewStateParser</code> is then used to parse the command word itself.</p>
</li>
<li>
<p>This results in a <code>Command</code> object which is executed by the <code>LogicManager</code>.</p>
</li>
<li>
<p>The execution of this command may affect the <code>Model</code> (e.g. when deleting a deck).</p>
</li>
<li>
<p>The result of the command execution is wrapped in a <code>CommandResult</code> object and returned back to <code>Ui</code>.</p>
</li>
<li>
<p>Different subclasses of <code>CommandResult</code> may instruct <code>Ui</code> to perform different actions,
such as <code>UpdatePanelCommandResult</code> which is used to construct a new <code>MainPanel</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To make things clearer, below is the Sequence Diagram for interactions within the <code>Logic</code> component given an <code>execute("delete 1")</code> API call.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/DeletePersonSdForLogic.png" alt="DeletePersonSdForLogic">
</div>
<div class="title">Figure 8. Interactions Inside the Logic Component for <code>delete 1</code></div>
</div>
</div>
<div class="sect2">
<h3 id="stateful-user-interface"><a class="link" href="#stateful-user-interface">4.3. Stateful user interface</a></h3>
<div class="sect3">
<h4 id="introduction-2"><a class="link" href="#introduction-2">4.3.1. Introduction</a></h4>
<div class="paragraph">
<p>TopDeck has a stateful user interface.
This means that the set of valid commands and their respective functionality
depend on the context of the application state.</p>
</div>
<div class="paragraph">
<p>For example, the command word <code>add</code> is "overloaded" with two capabilities:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In decks view, it adds a new deck: <code>add n/DECK_NAME</code></p>
</li>
<li>
<p>In cards view, it adds a new card to a particular deck: <code>add q/QUESTION a/ANSWER</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is the active state in TopDeck that resolves the actual command that is called.
Also, TopDeck does not request information from the user that is already implicit in the state
(e.g. the target deck in the second command).</p>
</div>
<div class="paragraph">
<p>The reasons for choosing to implement a stateful user interface are manifold.
Most importantly, it is necessary to support the implementation of study view which is stateful in nature.
A stateful user interface is also preferable to end users since it
requires less cognitive effort to operate by virtue of the fewer and shorter commands.</p>
</div>
<div class="paragraph">
<p>However, implementing state in full generality required nontrivial modifications to the AB4 architecture.
These modifications have been reflected in <a href="#Architecture">[Architecture]</a>.
We will now describe how state is implemented in TopDeck.</p>
</div>
</div>
<div class="sect3">
<h4 id="current-implementation"><a class="link" href="#current-implementation">4.3.2. Current implementation</a></h4>
<div class="paragraph">
<p>States partition the functionalities that are exposed to users.
Hence, it is natural to consider distinct views in the user interface as separate states.
States in TopDeck correspond to the three possible views described in the user guide:
decks view, cards view and study view.</p>
</div>
<div class="paragraph">
<p>Each state implements a common interface <code>ViewState</code>
and holds transient data that is relevant only while the state is active.
For example, <code>CardsView</code> has a member <code>activeDeck</code> which holds a reference to the deck opened in decks view.
Commands in cards view such as <code>add</code> will then operate on this deck.
The <code>ViewState</code> contract also requires each implementer to provide policies
for parsing and rendering used by <code>Logic</code> and <code>Ui</code> respectively. This is an example of the strategy pattern.</p>
</div>
<div class="paragraph">
<p><code>ModelManager</code> owns the sole instance of <code>ViewState</code>.
Having only one instance of any state makes it trivial to enforce mutual exclusion.
The <code>Model</code> is also responsible for executing state transitions.
Each transition is exposed as a method in the <code>Model</code> API.
For example, <code>Model#changeDeck(Deck deck)</code> implements the transition from decks view to cards view.
As state entry is handled by the constructors of each state,
the implementation of a transition is as simple as constructing a new state object.</p>
</div>
<div class="paragraph">
<p>Technically, <code>Model#changeDeck(Deck deck)</code> can be called from any state, not just decks view.
This is a consequence of the design of <code>Model</code>.
The <code>Model</code> API is designed such that no state tracking is necessary.
All methods are expected to work regardless of the current state.
We assume that if a caller is capable of providing the required arguments to a method,
the method call is valid and expected.
This obviates the need for state-checking code in <code>ModelManager</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations"><a class="link" href="#design-considerations">4.3.3. Design considerations</a></h4>
<div class="paragraph">
<p>The design of the state classes was a significant technical decision. Below were my considerations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Alternative 1: Keep the semantics of the original <code>Model</code> and put all state-specific fields and methods here. Maintain an enum to keep track of the active state.</p>
<div class="ulist">
<ul>
<li>
<p>Pros:</p>
<div class="ulist">
<ul>
<li>
<p>Does not require much initial modifications to AB4 to support</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cons:</p>
<div class="ulist">
<ul>
<li>
<p><code>Model</code> will contain a lot of irrelevant fields and methods throughout its lifetime such as <code>getUserAnswer()</code>.</p>
</li>
<li>
<p>Necessary to do a lot of switch-case checking, downcasting to concrete states and error handling of incorrect states.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Alternative 2 (current choice): Redefine the responsibilies of <code>Model</code> as above and put state-specific data and methods in the respective <code>ViewState</code> classes</p>
<div class="ulist">
<ul>
<li>
<p>Pros:</p>
<div class="ulist">
<ul>
<li>
<p>Separation of concerns. Allows different states to be developed independently.</p>
</li>
<li>
<p>Safety. It is harder to write wrong code if there are no irrelevant fields in a class.</p>
</li>
<li>
<p>Can use polymorphism to dynamically dispatch correct behaviour, obviating the need for switch-case checks.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cons:</p>
<div class="ulist">
<ul>
<li>
<p>Requires substantial modifications to AB4 to support and requires a rewrite of many tests.</p>
</li>
<li>
<p>Makes testing harder since the model must be initialised to the correct state.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Despite its initial ease of adoption, alternative 1 is difficult to extend and creates significant technical debt in the long run as more state-specific functionality is added to <code>Model</code>.
Thus, the choice is clear. Alternative 2 is preferable.</p>
</div>
</div>
</div>
</div>
</div></div><div id="footer"><div class="container"><div id="footer-text">Last updated 2019-04-16 09:39:16 UTC</div></div></div></body></html>